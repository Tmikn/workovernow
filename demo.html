<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>é»‘æš—åœ°ç‰¢é£ï¼šç¾å°‘å¥³ä¸D20åˆ¤å®š</title>
    <style>
        body { background: #050505; color: #e0e0e0; display: flex; flex-direction: column; align-items: center; font-family: 'Palatino', serif; margin: 0; overflow: hidden; }
        canvas { border: 2px solid #333; box-shadow: 0 0 50px #000; margin-top: 20px; image-rendering: pixelated; }
        .instructions { margin-top: 15px; text-align: center; color: #888; line-height: 1.6; }
        .highlight { color: #ff80bf; font-weight: bold; }
    </style>
</head>
<body>

    <div class="instructions">
        <span class="highlight">è–‡å¥¥æ‹‰çš„å®¡åˆ¤</span><br>
        [çŸ­ç‚¹å·¦é”®] åŸºç¡€æ”»å‡» | [é•¿æŒ‰å·¦é”®] å¼€å¯è½®ç›˜é€‰æ‹›<br>
        <small>D&D ç³»ç»Ÿï¼šåˆ¤å®š1=å¤§å¤±è´¥ï¼Œ18-20=æš´å‡»</small>
    </div>

    <canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- æ¸¸æˆé…ç½® ---
const state = {
    isWheelOpen: false,
    holdTime: 0,
    selectedSkill: -1,
    shake: 0,
    freeze: 0,
    timeScale: 1,
    msg: "ç­‰å¾…æˆ˜æ–—å¼€å§‹...",
    msgColor: "#fff"
};

const skills = [
    { name: "è¿æ·é‡å‡»", color: "#e74c3c", icon: "ğŸ”¨", diceBonus: 2, dmg: 25 },
    { name: "åœ£å…‰æƒ©æˆ’", color: "#f1c40f", icon: "âœ¨", diceBonus: 5, dmg: 15 },
    { name: "é“å£æ¶åŠ¿", color: "#3498db", icon: "ğŸ›¡ï¸", diceBonus: 0, dmg: 5 },
    { name: "é²œè¡€ç¥ˆç¥·", color: "#9b59b6", icon: "ğŸ·", diceBonus: -2, dmg: 40 }
];

const player = { x: 200, y: 280, offset: 0, targetOffset: 0, color: "#ff80bf", state: "idle" };
const boss = { x: 550, y: 220, hp: 100, maxHp: 100, shake: 0 };
const particles = [];

// --- è¾“å…¥é€»è¾‘ ---
let mouseDownTime = 0;
canvas.addEventListener('mousedown', (e) => {
    mouseDownTime = Date.now();
    state.holdTimer = setTimeout(() => {
        state.isWheelOpen = true;
    }, 200);
});

canvas.addEventListener('mousemove', (e) => {
    if (!state.isWheelOpen) return;
    const rect = canvas.getBoundingClientRect();
    updateWheelSelection(e.clientX - rect.left, e.clientY - rect.top);
});

window.addEventListener('mouseup', () => {
    clearTimeout(state.holdTimer);
    if (state.isWheelOpen) {
        if (state.selectedSkill !== -1) executeAttack(skills[state.selectedSkill]);
        state.isWheelOpen = false;
    } else if (Date.now() - mouseDownTime < 200) {
        executeAttack({ name: "åŸºç¡€æŒ¥ç ", color: "#fff", diceBonus: 0, dmg: 10 });
    }
});

// --- æˆ˜æ–—é€»è¾‘ ---
function executeAttack(skill) {
    if (player.state !== "idle") return;
    
    player.state = "attack";
    const roll = Math.floor(Math.random() * 20) + 1;
    const total = roll + skill.diceBonus;
    
    // æ¨¡æ‹Ÿæš—é»‘åœ°ç‰¢çš„å‰å†²æ„Ÿ
    player.targetOffset = 80;

    setTimeout(() => {
        if (roll === 1) {
            handleResult("å¤§å¤±è´¥!", "#ff4444", 0, 5);
        } else if (roll >= 18) {
            handleResult(`æš´å‡»! (D20:${roll}+${skill.diceBonus})`, "#ff80bf", skill.dmg * 2, 20, true);
        } else {
            handleResult(`å‘½ä¸­ (D20:${roll}+${skill.diceBonus})`, "#fff", skill.dmg, 8);
        }
        
        setTimeout(() => {
            player.targetOffset = 0;
            player.state = "idle";
        }, 150);
    }, 100);
}

function handleResult(text, color, damage, shakePower, isCrit = false) {
    state.msg = text;
    state.msgColor = color;
    state.shake = shakePower;
    boss.hp = Math.max(0, boss.hp - damage);
    if (isCrit) state.freeze = 12; // å¡è‚‰æ„Ÿ
    
    // å–·è¡€ç²’å­æ•ˆæœ
    for(let i=0; i<15; i++) {
        particles.push({
            x: boss.x + 60, y: boss.y + 80,
            vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15,
            life: 30, color: isCrit ? "#ff0080" : "#700"
        });
    }
}

function updateWheelSelection(mx, my) {
    const cx = canvas.width / 2, cy = canvas.height / 2;
    const dx = mx - cx, dy = my - cy;
    if (Math.sqrt(dx*dx + dy*dy) < 40) { state.selectedSkill = -1; return; }
    let angle = Math.atan2(dy, dx) + Math.PI / 2;
    if (angle < 0) angle += Math.PI * 2;
    state.selectedSkill = Math.floor(angle / (Math.PI * 2 / skills.length)) % skills.length;
}

// --- æ¸²æŸ“å¾ªç¯ ---
function draw() {
    if (state.freeze > 0) { state.freeze--; requestAnimationFrame(draw); return; }

    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    // å±å¹•éœ‡åŠ¨
    if (state.shake > 0) {
        ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake);
        state.shake *= 0.8;
    }

    // ç»˜åˆ¶åœ°é¢
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(0, 380); ctx.lineTo(800, 380); ctx.stroke();

    // ç»˜åˆ¶Boss (é™æ€å·¨å‹é»‘å½±)
    ctx.fillStyle = "#1a1a1a";
    ctx.strokeStyle = "#444";
    ctx.lineWidth = 3;
    ctx.strokeRect(boss.x, boss.y, 140, 160);
    ctx.fillRect(boss.x, boss.y, 140, 160);
    // Boss è¡€æ¡
    ctx.fillStyle = "#200"; ctx.fillRect(boss.x, boss.y-40, 140, 8);
    ctx.fillStyle = "#e74c3c"; ctx.fillRect(boss.x, boss.y-40, 140 * (boss.hp/100), 8);

    // ç»˜åˆ¶ä¸»è§’ (äºŒæ¬¡å…ƒç¾å°‘å¥³è‰²å—)
    player.offset += (player.targetOffset - player.offset) * 0.3;
    const px = player.x + player.offset;
    ctx.fillStyle = player.color;
    ctx.fillRect(px, player.y, 70, 100); 
    // çœ¼ç› (åå·®è®¾è®¡)
    ctx.fillStyle = "#000"; ctx.fillRect(px + 45, player.y + 25, 20, 4); 

    // ç»˜åˆ¶ç²’å­
    particles.forEach((p, i) => {
        p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life--;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 5, 5);
        if (p.life <= 0) particles.splice(i, 1);
    });

    ctx.restore();

    // ç»˜åˆ¶ä¿¡æ¯
    ctx.fillStyle = state.msgColor;
    ctx.font = "italic bold 24px Georgia";
    ctx.textAlign = "center";
    ctx.fillText(state.msg, canvas.width/2, 80);

    // ç»˜åˆ¶æŠ€èƒ½è½®ç›˜
    if (state.isWheelOpen) {
        drawWheel();
    }

    requestAnimationFrame(draw);
}

function drawWheel() {
    const cx = canvas.width / 2, cy = canvas.height / 2, r = 130;
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0,0,canvas.width, canvas.height);

    skills.forEach((s, i) => {
        const step = (Math.PI * 2) / skills.length;
        const start = i * step - Math.PI / 2;
        const end = (i + 1) * step - Math.PI / 2;
        
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, r, start, end);
        ctx.fillStyle = (state.selectedSkill === i) ? s.color : "#222";
        ctx.globalAlpha = (state.selectedSkill === i) ? 0.9 : 0.5;
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.globalAlpha = 1;

        // å›¾æ ‡ä¸æ–‡å­—
        const tx = cx + Math.cos(start + step/2) * (r * 0.7);
        const ty = cy + Math.sin(start + step/2) * (r * 0.7);
        ctx.fillStyle = "#fff";
        ctx.font = "20px Arial";
        ctx.fillText(s.icon, tx, ty - 5);
        ctx.font = "12px Arial";
        ctx.fillText(s.name, tx, ty + 15);
    });
}

draw();
</script>
</body>
</html>
