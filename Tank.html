<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>坦克: 大战</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }

        /* 启动遮罩 */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 5000;
            color: #9B409E;
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            z-index: 100;
            width: calc(100% - 40px);
            display: none;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .bar-container {
            width: 200px;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 5px;
            border-radius: 6px;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background: #ff4444;
            transition: width 0.3s;
        }

        #exp-bar {
            width: 0%;
            height: 100%;
            background: #00f2ff;
            transition: width 0.3s;
        }

        /* 升级界面 */
        #upgrade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .upgrade-card {
            background: #1a1a1a;
            border: 2px solid #9B409E;
            color: white;
            padding: 20px;
            margin: 10px;
            width: 260px;
            cursor: pointer;
            text-align: center;
            border-radius: 10px;
        }

        .upgrade-card:hover {
            border-color: #00f2ff;
            transform: scale(1.05);
        }

        /* 摇杆 */
        .joystick-zone {
            position: fixed;
            bottom: 40px;
            width: 120px;
            height: 120px;
            z-index: 1000;
            display: none;
            touch-action: none;
        }

        #joy-left {
            left: 40px;
        }

        #joy-right {
            right: 40px;
        }

        .joy-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .joy-stick {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #9B409E;
            position: absolute;
            top: 35px;
            left: 35px;
        }

        button {
            padding: 15px 40px;
            background: #9B409E;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            font-size: 1.2em;
        }
    </style>
</head>

<body>

    <div id="btn-lang"
        style="position: fixed; top: 20px; right: 70px; width: 40px; height: 40px; background: rgba(0,0,0,0.5); border: 2px solid #9B409E; color: #9B409E; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 9999; font-weight: bold; font-size: 14px;">
        EN
    </div>

    <div id="start-overlay">
        <h1 id="t-title" style="margin-bottom: 40px;">坦克: 大战</h1>
        <button id="start-btn"><span id="t-start">初始化作战系统</span></button>
        <p id="t-tips" style="color: #666; margin-top: 20px;">[ W/S 进退 | A/D 转向 | 鼠标 瞄准 ]</p>
    </div>

    <div id="ui">
        <div class="stats-column" style="display: flex; flex-direction: column; gap: 8px;">
            <div>
                <div style="font-size:12px; color:#00f2ff; font-weight:bold; letter-spacing:1px;">
                    <span id="t-lvl">LVL</span> <span id="lvl-val">1</span>
                </div>
                <div class="bar-container">
                    <div id="exp-bar"></div>
                </div>
            </div>
            <div>
                <div style="font-size:12px; color:#ff4444; font-weight:bold; letter-spacing:1px;" id="t-hull">
                    HULL INTEGRITY
                </div>
                <div class="bar-container">
                    <div id="hp-bar"></div>
                </div>
            </div>
            <div style="color: #9B409E; font-weight: bold; font-size: 14px; margin-top: 5px;">
                <span id="t-score">SCORE:</span> <span id="score-val">0</span>
            </div>
        </div>
    </div>

    <div id="joy-left" class="joystick-zone">
        <div class="joy-base">
            <div class="joy-stick" id="stick-l"></div>
        </div>
    </div>
    <div id="joy-right" class="joystick-zone">
        <div class="joy-base">
            <div class="joy-stick" id="stick-r"></div>
        </div>
    </div>

    <div id="upgrade-overlay">
        <h2 id="t-upg-title" style="color: #9B409E;">系统组件进化</h2>
        <div id="upgrade-options" style="display: flex; flex-wrap: wrap; justify-content: center;"></div>
    </div>

    <div id="gameover-overlay"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(139,0,0,0.85); z-index:4000; display:none; flex-direction:column; align-items:center; justify-content:center; color:white;">
        <h1 id="t-go-title" style="font-size:3em; margin-bottom:10px;">失去链接...</h1>
        <p style="font-size:1.5em; margin-bottom:30px;"><span id="t-go-score">最终评分:</span> <span
                id="final-score">0</span></p>
        <button id="btn-restart"><span id="t-restart">重新开始</span></button>
    </div>

    <div id="pause-trigger"
        style="position: fixed; top: 20px; right: 20px; width: 40px; height: 40px; background: rgba(0,0,0,0.5); border: 2px solid #00f2ff; color: #00f2ff; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; z-index: 500; font-weight: bold;">
        ‖</div>

    <div id="pause-overlay"
        style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:3500; display:none; flex-direction:column; align-items:center; justify-content:center; color:#00f2ff;">
        <h1 id="t-pause-title" style="font-size:3em; text-shadow: 0 0 10px #00f2ff;">系统已挂起</h1>
        <p style="color: white; margin-bottom: 30px;">PAUSED</p>
        <button id="btn-resume"><span id="t-resume">恢复作战</span></button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /** --- 多语言系统 (i18n) --- **/
        let currentLang = 'zh'; // 默认中文

        const dict = {
            zh: {
                title: "坦克: 大战", start: "初始化作战系统", tips: "[ W/S 进退 | A/D 转向 | 鼠标 瞄准 ]",
                lvl: "等级", hull: "生命值", score: "得分:",
                upgTitle: "系统组件进化",
                goTitle: "失去链接...", goScore: "最终评分:", restart: "重新部署",
                pauseTitle: "系统已挂起", resume: "恢复作战",

                // 升级卡片文案
                fireName: "并联炮管", fireDesc: "增加额外火力点",
                rateName: "自动装填", rateDesc: "射击频率提升 25%",
                speedName: "大马力引擎", speedDesc: "行进速度大幅提升",
                sizeName: "爆裂弹头", sizeDesc: "增加子弹体积与命中判定",
                hullName: "装甲加固", hullDesc: "提升最大生命值并修复车体",
                servoName: "伺服电机", servoDesc: "炮塔转向响应大幅提升",
                ramName: "重型冲角", ramDesc: "对撞击到的敌人造成持续伤害",
                dmgName: "贫铀穿甲弹", dmgDesc: "主炮基础伤害提升 30 点",
                laserName: "高能激光束", laserDesc: "在炮塔侧面加装激光器，再次升级增加持续时间与伤害",
                sentryName: "浮游哨戒炮", sentryDesc: "增加一台自动锁定并攻击敌人的悬浮机炮，最多叠加4台"
            },
            en: {
                title: "TANK: COMBAT", start: "INITIALIZE SYSTEM", tips: "[ W/S Move | A/D Turn | Mouse Aim ]",
                lvl: "LVL", hull: "HP", score: "SCORE:",
                upgTitle: "SYSTEM EVOLUTION",
                goTitle: "CONNECTION LOST...", goScore: "Final Score:", restart: "REDEPLOY",
                pauseTitle: "SYSTEM SUSPENDED", resume: "RESUME COMBAT",

                // Upgrade Cards Text
                fireName: "Twin Barrels", fireDesc: "Adds an extra firing point",
                rateName: "Autoloader", rateDesc: "Increases fire rate by 25%",
                speedName: "V8 Engine", speedDesc: "Drastically increases movement speed",
                sizeName: "HE Shells", sizeDesc: "Increases bullet size and hitbox",
                hullName: "Reinforced Armor", hullDesc: "Increases Max HP and repairs hull",
                servoName: "Servo Motor", servoDesc: "Drastically increases turret rotation speed",
                ramName: "Spiked Bumper", ramDesc: "Deals continuous damage to rammed enemies",
                dmgName: "DU Shells", dmgDesc: "Increases base damage by 30",
                laserName: "Energy Laser", laserDesc: "Mounts a laser. Upgrading increases duration and damage",
                sentryName: "Auto Sentry", sentryDesc: "Adds a hovering drone that auto-targets enemies. Max 4"
            }
        };

        function applyLanguage() {
            const t = dict[currentLang];
            document.getElementById('t-title').innerText = t.title;
            document.getElementById('t-start').innerText = t.start;
            document.getElementById('t-tips').innerText = t.tips;
            document.getElementById('t-lvl').innerText = t.lvl;
            document.getElementById('t-hull').innerText = t.hull;
            document.getElementById('t-score').innerText = t.score;
            document.getElementById('t-upg-title').innerText = t.upgTitle;
            document.getElementById('t-go-title').innerText = t.goTitle;
            document.getElementById('t-go-score').innerText = t.goScore;
            document.getElementById('t-restart').innerText = t.restart;
            document.getElementById('t-pause-title').innerText = t.pauseTitle;
            document.getElementById('t-resume').innerText = t.resume;
            document.getElementById('btn-lang').innerText = currentLang === 'zh' ? '中' : 'EN';
        }

        // 绑定语言切换按钮
        document.getElementById('btn-lang').onclick = () => {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            applyLanguage();
        };

        // 初始化时调用一次，应用默认语言
        applyLanguage();

        /** --- 1. 初始化变量与音频 --- **/
        let gameActive = false, score = 0, level = 1, exp = 0, expNeeded = 5;
        let playerHP = 100, maxHP = 100;
        const MAP_SIZE = 200;
        const enemies = [], bullets = [], keys = {};
        const debrisParticles = [];

        /** --- 音效资源配置 --- **/
        // 射击音效 (高音、短促)
        const fireSound = new Audio('music/344312__musiclegends__laser-shoot7.wav');
        fireSound.volume = 0.3;

        // 爆炸音效 (低音、厚重)
        const explodeSound = new Audio('music/517664__devern__8-bit-cannon.wav');
        explodeSound.volume = 0.5;

        /** * 核心：重叠播放函数
         * 解决问题：如果连续快速点击，上一个声音没播完，下一个声音播不出来。
         **/
        function playSound(audioNode) {
            const clone = audioNode.cloneNode(); // 克隆一个副本
            clone.volume = audioNode.volume;
            clone.play();
        }

        // 音乐设置
        const bgm = new Audio('music/Brain Dance.mp3'); // 示例合成器音乐
        bgm.loop = true;
        bgm.volume = 0.4;

        const stats = {
            moveSpeed: 0.22,
            fireRate: 800,
            bulletSize: 0.35,
            bulletSpeed: 1.25,
            multiShot: 1,
            turretSpeed: 0.065,
            lastFire: 0,

            // --- 新增的模块化战斗属性 ---
            bulletDamage: 50, // 子弹基础伤害
            ramDamage: 0,      // 碰撞伤害（每帧造成的伤害）
            armor: 0,           // 减伤装甲

            laserLevel: 0,        // 激光等级 (0代表还没获得)
            laserDuration: 300,   // 激光持续时间 (毫秒)，初始0.3秒
            laserCooldown: 3000,  // 激光冷却时间 (3秒发射一次)
            laserLastFire: 0,      // 上次发射时间记录

            sentryCount: 0,        // 哨戒炮数量 (初始0，最高4)
            sentryFireRate: 800,   // 哨戒炮射击间隔 (毫秒)
            sentryRange: 50        // 索敌范围
        };

        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let joyL = { x: 0, y: 0, active: false };
        let joyR = { x: 0, y: 0, active: false };

        /** --- 强化版长方形辉光拖尾资源 --- **/
        const trailParticles = [];
        const trailGeo = new THREE.PlaneGeometry(2.0, 0.6); // 宽度设为2.0，刚好覆盖车尾灯宽度
        trailGeo.rotateX(-Math.PI / 2); // 平铺地面

        const trailMatBase = new THREE.MeshBasicMaterial({
            color: 0x9B409E,      // 深红色核心
            transparent: true,
            opacity: 0.1,         // 初始透明度低一点，靠叠加产生辉光
            blending: THREE.AdditiveBlending, // 核心：开启辉光叠加模式
            depthWrite: false,    // 不写入深度缓冲区，防止方块边缘遮挡
            side: THREE.DoubleSide
        });


        /** --- 2. 场景构建 --- **/
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0a, 50, 200);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(50, 50, 50);
        scene.add(light);

        const floor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshPhongMaterial({ color: 0x111111 }));
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        scene.add(new THREE.GridHelper(600, 60, 0x444444, 0x111111));

        // 空气墙视觉
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(MAP_SIZE, 0.4, 16, 100),
            new THREE.MeshBasicMaterial({ color: 0x9B409E, transparent: true, opacity: 0.3 })
        );
        ring.rotation.x = Math.PI / 2;
        scene.add(ring);

        /** --- 3. 坦克逻辑 --- **/
        function createTank(color) {
            const group = new THREE.Group();

            // --- 底盘总组 ---
            const chassis = new THREE.Group();

            // 1. 主车体
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2.4, 0.8, 3.2),
                new THREE.MeshPhongMaterial({ color })
            );
            body.position.y = 0.4;
            chassis.add(body);

            // 2. 车头标识：探照灯 (位于 +Z 端)
            const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // 青色强光

            const leftLight = new THREE.Mesh(lightGeo, lightMat);
            leftLight.position.set(0.8, 0.6, 1.6);
            chassis.add(leftLight);

            const rightLight = new THREE.Mesh(lightGeo, lightMat);
            rightLight.position.set(-0.8, 0.6, 1.6);
            chassis.add(rightLight);

            if (color === 0x9B409E) {
                // 左车灯点光源 (颜色, 强度, 距离)
                const leftPointLight = new THREE.PointLight(0xffffff, 1.5, 12);
                leftPointLight.position.set(0.8, 0.6, 1.8);
                chassis.add(leftPointLight);

                // 右车灯点光源
                const rightPointLight = new THREE.PointLight(0xffffff, 1.5, 12);
                rightPointLight.position.set(-0.8, 0.6, 1.8);
                chassis.add(rightPointLight);

                // 可选：给车尾加一个微弱的红光感
                const tailPointLight = new THREE.PointLight(0x9B409E, 0.8, 5);
                tailPointLight.position.set(0, 0.4, -1.8);
                chassis.add(tailPointLight);
            }

            // 3. 车尾标识：尾灯与排气管 (位于 -Z 端)
            const tailLightMat = new THREE.MeshBasicMaterial({ color: 0x9B409E }); // 红色尾灯
            const tailLight = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 0.1), tailLightMat);
            tailLight.position.set(0, 0.4, -1.6);
            chassis.add(tailLight);

            const pipeGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.5);
            const pipeMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const pipe = new THREE.Mesh(pipeGeo, pipeMat);
            pipe.rotation.x = Math.PI / 2;
            pipe.position.set(0.7, 0.3, -1.7);
            chassis.add(pipe);

            group.add(chassis);

            // --- 炮塔总组 ---
            const turretGroup = new THREE.Group();
            turretGroup.position.y = 0.9;

            const head = new THREE.Mesh(
                new THREE.BoxGeometry(1.6, 0.6, 1.6),
                new THREE.MeshPhongMaterial({ color })
            );
            turretGroup.add(head);

            const barrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.12, 0.15, 2.4),
                new THREE.MeshPhongMaterial({ color: 0x222222 })
            );
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.1, 1.3);
            turretGroup.add(barrel);

            group.add(turretGroup);

            // 【核心修改】：赋予随机开火冷却、初始蓄力错开、以及运动随机种子
            group.userData = { 
                chassis: chassis, 
                turretGroup: turretGroup, 
                // 错开出生时的开火时间，防止一刷出来就同步开火
                lastFire: Date.now() - Math.random() * 3500, 
                // 专属的开火间隔：2.5秒 到 4.5秒 之间随机
                fireInterval: 2500 + Math.random() * 2000,   
                // 专属运动种子，用于制造不同的走位轨迹
                randomSeed: Math.random() * 100              
            };

            // --- 插入部分：副武器激光发射器 (仅玩家专属) ---
            if (color === 0x9B409E) {
                // 1. 激光器本体
                const emitterGeo = new THREE.BoxGeometry(0.25, 0.25, 0.8);
                const emitterMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const laserEmitter = new THREE.Mesh(emitterGeo, emitterMat);
                laserEmitter.position.set(0.35, 0.1, 0.8);
                laserEmitter.visible = false;
                turretGroup.add(laserEmitter);

                // 发射器前端
                const tipGeo = new THREE.BoxGeometry(0.2, 0.2, 0.1);
                const tipMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const tip = new THREE.Mesh(tipGeo, tipMat);
                tip.position.set(0, 0, 0.45);
                laserEmitter.add(tip);

                // 2. 激光光束
                const beamGeo = new THREE.CylinderGeometry(0.08, 0.08, 150);
                beamGeo.rotateX(Math.PI / 2);
                beamGeo.translate(0, 0, 75);
                const beamMat = new THREE.MeshBasicMaterial({
                    color: 0x00ff00, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
                });
                const laserBeam = new THREE.Mesh(beamGeo, beamMat);
                laserBeam.visible = false;
                laserEmitter.add(laserBeam);

                // 追加进 userData，安全了！
                group.userData.laserEmitter = laserEmitter;
                group.userData.laserBeam = laserBeam;
            }
            // --- 插入部分：浮游哨戒炮 (预生成4个) ---
            const sentries = [];
            const sentryGeo = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const sentryMat = new THREE.MeshPhongMaterial({ color: 0x00f2ff }); // 青色高科技涂装
            const barrelGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.8);
            barrelGeo.rotateX(Math.PI / 2);

            for (let i = 0; i < 4; i++) {
                const drone = new THREE.Group();

                // 无人机机体
                const body = new THREE.Mesh(sentryGeo, sentryMat);
                drone.add(body);

                // 无人机枪管
                const droneBarrel = new THREE.Mesh(barrelGeo, new THREE.MeshPhongMaterial({ color: 0x333333 }));
                droneBarrel.position.set(0, 0, 0.4);
                drone.add(droneBarrel);

                drone.visible = false; // 默认隐藏
                // 把无人机直接挂在顶层 group 上，这样它只会跟着移动，不会跟着底盘乱转
                group.add(drone);

                // 记录它的独立开火时间和环绕角度
                sentries.push({ model: drone, lastFire: 0, angle: (Math.PI / 2) * i });
            }
            group.userData.sentries = sentries;
            // --- 给敌人添加 3D 血条 ---
            if (color !== 0x9B409E) {
                const hpGroup = new THREE.Group();
                hpGroup.position.y = 3.0;

                const bgGeo = new THREE.PlaneGeometry(2.0, 0.25);
                const bgMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                const bgMesh = new THREE.Mesh(bgGeo, bgMat);
                hpGroup.add(bgMesh);

                const fgGeo = new THREE.PlaneGeometry(2.0, 0.25);
                fgGeo.translate(1.0, 0, 0);
                const fgMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const fgMesh = new THREE.Mesh(fgGeo, fgMat);
                fgMesh.position.x = -1.0;
                fgMesh.position.z = 0.01;
                hpGroup.add(fgMesh);

                group.add(hpGroup);

                // 同样安全追加
                group.userData.hpGroup = hpGroup;
                group.userData.hpBar = fgMesh;
            }

            scene.add(group);
            return group;
        }


        const player = createTank(0x9B409E);

        /** --- 4. 核心输入逻辑 (PC硬核坦克 + 手机绝对方位双摇杆) --- **/
        function updateInputs() {
            let isMoving = false;

            // ==========================================
            // 1. PC 端逻辑 (键盘：WS相对进退，AD原地转向)
            // ==========================================
            let pcRotDir = 0;
            let pcMoveVal = 0;

            if (keys['a']) pcRotDir += 1;
            if (keys['d']) pcRotDir -= 1;
            if (keys['w']) pcMoveVal += stats.moveSpeed;
            if (keys['s']) pcMoveVal -= stats.moveSpeed;

            // PC端发生操作时
            if (pcRotDir !== 0 || pcMoveVal !== 0) {
                // 原地转向 (保留原本的 0.045 速度)
                player.userData.chassis.rotation.y += pcRotDir * 0.045;

                // 相对车头方向位移
                if (pcMoveVal !== 0) {
                    const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(player.userData.chassis.quaternion);
                    player.position.add(dir.multiplyScalar(pcMoveVal));
                    if (keys['w']) isMoving = true; // 只有按 W 前进时才算作触发拖尾的“移动”
                }
            }

            // ==========================================
            // 2. 手机端逻辑 (左摇杆：绝对方向位移 + 平滑转向)
            // ==========================================
            if (joyL.active) {
                const moveX = -joyL.x;
                const moveZ = -joyL.y;
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);

                // 添加一点摇杆死区，防止误触
                if (length > 0.1) {
                    // (1) 绝对位移：往哪推就往哪走
                    const normX = moveX / length;
                    const normZ = moveZ / length;

                    // 根据推摇杆的力度计算速度
                    const speedMult = Math.min(length, 1) * stats.moveSpeed;
                    player.position.x += normX * speedMult;
                    player.position.z += normZ * speedMult;

                    // (2) 底盘平滑转向：让车头转向摇杆方向，【严格保留 0.045 的转向速度】
                    const targetAngle = Math.atan2(normX, normZ);
                    const targetQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngle);

                    // rotateTowards 的第二个参数是每次渲染转动的最大弧度，0.045 完美还原之前的重量感
                    player.userData.chassis.quaternion.rotateTowards(targetQ, 0.045);

                    isMoving = true; // 摇杆推了就算移动
                }
            }

            // 保存移动状态，供拖尾系统读取
            player.userData.isMoving = isMoving;

            // ==========================================
            // 3. 通用逻辑 (空气墙与炮塔转向)
            // ==========================================
            // 空气墙硬限制
            if (player.position.length() > MAP_SIZE) {
                player.position.setLength(MAP_SIZE);
            }

            // 炮塔平滑指向
            let targetAngleTurret = player.userData.turretGroup.rotation.y;
            if (joyR.active) {
                targetAngleTurret = Math.atan2(-joyR.x, -joyR.y);
            } else {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(floor);
                if (intersects.length > 0) {
                    const pt = intersects[0].point;
                    targetAngleTurret = Math.atan2(pt.x - player.position.x, pt.z - player.position.z);
                }
            }
            const targetQTurret = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetAngleTurret);
            player.userData.turretGroup.quaternion.rotateTowards(targetQTurret, stats.turretSpeed);
        }

        /** --- 5. 战斗与循环 --- **/
        function fireBullet(owner, isPlayer) {
            const count = isPlayer ? stats.multiShot : 1;
            if (isPlayer) {
                playSound(fireSound);
            }
            for (let i = 0; i < count; i++) {
                const b = new THREE.Mesh(new THREE.SphereGeometry(isPlayer ? stats.bulletSize : 0.28),
                    new THREE.MeshBasicMaterial({ color: isPlayer ? 0x00f2ff : 0xff4444 }));
                b.position.copy(owner.position).add(new THREE.Vector3(0, 1.2, 0));
                const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.userData.turretGroup.quaternion);
                if (isPlayer && count > 1) dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), (i - (count - 1) / 2) * 0.2);
                b.userData = { velocity: dir.multiplyScalar(isPlayer ? stats.bulletSpeed : 0.45), owner: isPlayer ? 'p' : 'e' };
                bullets.push(b); scene.add(b);
            }
        }


        function spawnTrail() {
            if (trailParticles.length > 40) return; // 限制数量防止过卡

            const chassis = player.userData.chassis;

            // 位置设定在车尾正中心 (Z=-1.7)，高度略微离地 (Y=0.2)
            const centerExhaustPos = new THREE.Vector3(0, 0.2, -1.7);
            chassis.localToWorld(centerExhaustPos);

            const mat = trailMatBase.clone();
            const p = new THREE.Mesh(trailGeo, mat);

            p.position.copy(centerExhaustPos);
            // 让拖尾的旋转跟随底盘的旋转
            p.quaternion.copy(chassis.getWorldQuaternion(new THREE.Quaternion()));

            p.userData = { life: 1.0 };
            scene.add(p);
            trailParticles.push(p);
        }

        function createExplosion(pos, color) {
            // 1. 爆炸核心闪光 (瞬间爆亮的点光源)
            const flash = new THREE.PointLight(0xffaa00, 3.0, 15);
            flash.position.copy(pos);
            flash.position.y += 1.0;
            scene.add(flash);

            // 把闪光加入数组，利用生命周期让它迅速变暗
            debrisParticles.push({ mesh: flash, isLight: true, life: 1.0, decay: 0.15 });

            // 2. 生成装甲碎块 (8~12 块随机碎片)
            const pieceCount = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < pieceCount; i++) {
                // 随机尺寸
                const size = 0.3 + Math.random() * 0.4;
                const geo = new THREE.BoxGeometry(size, size, size);
                // 材质继承死掉坦克的颜色，但稍微暗一点模拟烧焦
                const mat = new THREE.MeshPhongMaterial({ color: color });
                const piece = new THREE.Mesh(geo, mat);

                piece.position.copy(pos);
                piece.position.y += 0.8;

                // 物理属性：赋予一个向上的抛物线初速度，并向四周炸开
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1.2,
                    Math.random() * 0.8 + 0.4, // 向上抛的力
                    (Math.random() - 0.5) * 1.2
                );

                // 随机的翻滚速度
                const rotSpeed = new THREE.Vector3(
                    Math.random() * 0.4 - 0.2,
                    Math.random() * 0.4 - 0.2,
                    Math.random() * 0.4 - 0.2
                );

                scene.add(piece);
                debrisParticles.push({
                    mesh: piece,
                    isLight: false,
                    velocity: velocity,
                    rotSpeed: rotSpeed,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.02 // 随机消失速度
                });
            }
        }

        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);

            updateInputs();

            // --- 1. 拖尾生成逻辑 ---
            // 判断是否在前进 (按W 或 左摇杆向上推)
            const isMovingForward = keys['w'] || (joyL.active && joyL.y < -0.2);

            if (player.userData.isMoving) {
                spawnTrail();
            }

            // --- 2. 拖尾更新循环 ---
            // 必须在渲染前处理粒子的生命周期
            for (let i = trailParticles.length - 1; i >= 0; i--) {
                const p = trailParticles[i];
                p.userData.life -= 0.03; // 衰减速度

                // 视觉进化逻辑：
                p.material.opacity = p.userData.life * 0.2; // 基础透明度

                // 这种拉伸效果会让拖尾看起来像流动的光束
                p.scale.z += 0.05; // 长度伸展
                p.scale.x *= 0.98; // 宽度微弱收缩

                // 稍微向后方移动一点点，模拟惯性
                const backward = new THREE.Vector3(0, 0, -0.1).applyQuaternion(p.quaternion);
                p.position.add(backward);

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    p.material.dispose();
                    trailParticles.splice(i, 1);
                }
            }

            // ---2.5 插入部分：爆炸碎块物理模拟 ---
            for (let i = debrisParticles.length - 1; i >= 0; i--) {
                const p = debrisParticles[i];
                p.life -= p.decay;

                if (p.isLight) {
                    // 光源迅速变暗
                    p.mesh.intensity = p.life * 3.0;
                } else {
                    // 碎块受重力影响下坠
                    p.velocity.y -= 0.05;
                    p.mesh.position.add(p.velocity);
                    // 碎块空中翻滚
                    p.mesh.rotation.x += p.rotSpeed.x;
                    p.mesh.rotation.y += p.rotSpeed.y;
                    p.mesh.rotation.z += p.rotSpeed.z;

                    // 落地反弹逻辑
                    if (p.mesh.position.y < 0.2) {
                        p.mesh.position.y = 0.2;
                        p.velocity.y *= -0.4; // 触地反弹，动能衰减
                        p.velocity.x *= 0.8;  // 触地摩擦力
                        p.velocity.z *= 0.8;
                    }

                    // 临近消失时逐渐缩小
                    if (p.life < 0.4) {
                        const scale = p.life * 2.5;
                        p.mesh.scale.set(scale, scale, scale);
                    }
                }

                // 生命周期结束，清理内存
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    if (!p.isLight) {
                        p.mesh.geometry.dispose();
                        p.mesh.material.dispose();
                    }
                    debrisParticles.splice(i, 1);
                }
            }

            // --- 3. 自动开火逻辑 ---
            if (Date.now() - stats.lastFire > stats.fireRate) {
                fireBullet(player, true);
                stats.lastFire = Date.now();
            }

            // --- 4. 敌人 AI (带有蛇形走位和随机开火) ---
            const nowTime = Date.now(); // 获取当前统一时间
            enemies.forEach(en => {
                // 计算指向玩家的绝对基础向量
                const dirToPlayer = new THREE.Vector3().subVectors(player.position, en.position).normalize();
                const baseAngle = Math.atan2(dirToPlayer.x, dirToPlayer.z);

                // 1. 运动逻辑：蛇形走位
                // 利用正弦波(sin)和敌人的随机种子，算出一个左右摇摆的偏移角度 (0.6 弧度约等于 34 度)
                const swayAngle = baseAngle + Math.sin(nowTime * 0.0015 + en.userData.randomSeed) * 0.6;
                
                // 让底盘平滑地转向这个带偏移的路线
                const targetQChassis = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), swayAngle);
                en.userData.chassis.quaternion.rotateTowards(targetQChassis, 0.05);

                // 让炮塔始终精准瞄准玩家 (稍微平滑一点，体现重量感)
                const targetQTurret = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), baseAngle);
                en.userData.turretGroup.quaternion.rotateTowards(targetQTurret, 0.08);

                // 血条永远正对摄像机
                if (en.userData.hpGroup) {
                    en.userData.hpGroup.quaternion.copy(camera.quaternion);
                }

                // 距离判定与位移：【注意这里】由于底盘方向变了，要让它沿着底盘当前朝向前进，而不是直指玩家
                if (en.position.distanceTo(player.position) > 8) {
                    // 提取底盘的 Z 轴朝向作为实际运动方向
                    const moveDir = new THREE.Vector3(0, 0, 1).applyQuaternion(en.userData.chassis.quaternion);
                    en.position.add(moveDir.multiplyScalar(0.08 + level * 0.005));
                }

                // 2. 开火逻辑：独立随机冷却
                if (nowTime - en.userData.lastFire > en.userData.fireInterval) {
                    fireBullet(en, false);
                    en.userData.lastFire = nowTime;
                    // 开完火后，再给下一次开火随机一个新时间，彻底打乱节奏
                    en.userData.fireInterval = 2500 + Math.random() * 2000; 
                }
            });

            // --- 5. 碰撞与战斗 (保持你原有的逻辑) ---
            // ... 碰撞检测代码 ...
            const units = [player, ...enemies];
            for (let i = 0; i < units.length; i++) {
                for (let j = i + 1; j < units.length; j++) {
                    const a = units[i], b = units[j];
                    const dist = a.position.distanceTo(b.position);
                    if (dist < 3.2) {
                        // 原有的物理推开逻辑
                        const push = (3.2 - dist) * 0.5;
                        const vec = new THREE.Vector3().subVectors(a.position, b.position).normalize();
                        a.position.add(vec.clone().multiplyScalar(push * 0.2));
                        b.position.sub(vec.clone().multiplyScalar(push * 0.8));

                        // 【新增】玩家撞击敌人造成伤害 (a 是玩家的情况)
                        if (a === player && stats.ramDamage > 0) {
                            b.userData.hp -= stats.ramDamage; // 每帧扣血
                            // --- 插入部分：更新血条 UI ---
                            const hpPercent = Math.max(0, enemies[j].userData.hp / enemies[j].userData.maxHp);
                            enemies[j].userData.hpBar.scale.x = hpPercent;

                            // 变色逻辑：血量低于一半变黄，低于 20% 变红
                            if (hpPercent <= 0.2) enemies[j].userData.hpBar.material.color.setHex(0xff0000);
                            else if (hpPercent <= 0.5) enemies[j].userData.hpBar.material.color.setHex(0xffff00);
                            // --------------------------
                            if (b.userData.hp <= 0 && !b.userData.dead) {
                                b.userData.dead = true; // 防止一帧内重复触发wwwww
                                playSound(explodeSound);
                                // --- 插入触发爆炸 (传入敌人坐标和红色) ---
                                createExplosion(b.position.clone(), 0xA9A9A9);
                                scene.remove(b);
                                enemies.splice(enemies.indexOf(b), 1);
                                gainExp(1);
                            }
                        }
                    }
                }
            }

            // --- 6. 光源微闪效果 ---
            player.userData.chassis.children.forEach(child => {
                if (child instanceof THREE.PointLight && child.color.getHex() === 0xffffff) {
                    child.intensity = 1.4 + Math.random() * 0.3;
                }
            });
            // --- 插入部分：激光开火与伤害逻辑 ---
            if (stats.laserLevel > 0) {
                const now = Date.now();
                // 1. 判断是否该开火了
                if (!player.userData.isLaserActive && now - stats.laserLastFire > stats.laserCooldown) {
                    player.userData.isLaserActive = true;
                    player.userData.laserStartTime = now;
                    player.userData.laserBeam.visible = true; // 显示光束
                    stats.laserLastFire = now;
                    // 可以借用子弹开火音效，或者以后加个专用的
                    playSound(fireSound);
                }

                // 2. 如果激光正在持续输出中
                if (player.userData.isLaserActive) {
                    if (now - player.userData.laserStartTime > stats.laserDuration) {
                        // 持续时间结束，关闭激光
                        player.userData.isLaserActive = false;
                        player.userData.laserBeam.visible = false;
                    } else {
                        // 视觉效果：让激光束不停抖动变粗变细，产生高能不稳定感
                        player.userData.laserBeam.scale.set(1 + Math.random(), 1 + Math.random(), 1);

                        // 伤害判定：计算每个敌人到激光射线的距离
                        const emitterPos = new THREE.Vector3();
                        player.userData.laserEmitter.getWorldPosition(emitterPos);

                        // 获取炮塔此时的绝对朝向
                        const turretDir = new THREE.Vector3(0, 0, 1).applyQuaternion(
                            player.userData.turretGroup.getWorldQuaternion(new THREE.Quaternion())
                        ).normalize();

                        for (let j = enemies.length - 1; j >= 0; j--) {
                            const en = enemies[j];
                            // 数学向量计算：敌人坐标到发射点的向量
                            const v = new THREE.Vector3().subVectors(en.position, emitterPos);
                            // 投影长度 (敌人在发射方向前方多远)
                            const distAlongRay = v.dot(turretDir);

                            // 如果敌人在前方，且在 150 码射程内
                            if (distAlongRay > 0 && distAlongRay < 150) {
                                // 算出射线上距离敌人最近的一个点
                                const projectedPoint = emitterPos.clone().add(turretDir.clone().multiplyScalar(distAlongRay));
                                // 如果敌人离激光束小于 1.8 (命中判定半径)
                                if (en.position.distanceTo(projectedPoint) < 1.8) {

                                    // 持续扣血：因为这是每帧执行的，所以单次伤害不能太高
                                    // 满级激光一扫过去直接清屏！
                                    en.userData.hp -= (1.5 * stats.laserLevel);

                                    // 更新血条UI (直接复用你之前的逻辑)
                                    const hpPercent = Math.max(0, en.userData.hp / en.userData.maxHp);
                                    en.userData.hpBar.scale.x = hpPercent;
                                    if (hpPercent < 0.2) en.userData.hpBar.material.color.setHex(0xff0000);
                                    else if (hpPercent < 0.5) en.userData.hpBar.material.color.setHex(0xffff00);

                                    // 击杀判定
                                    if (en.userData.hp <= 0 && !en.userData.dead) {
                                        en.userData.dead = true;
                                        playSound(explodeSound);
                                        if (typeof createExplosion === 'function') createExplosion(en.position.clone(), 0xff4444);
                                        scene.remove(en);
                                        enemies.splice(j, 1);
                                        gainExp(1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // --- 插入部分：哨戒炮 AI 逻辑 ---
            if (stats.sentryCount > 0) {
                const now = Date.now();

                for (let i = 0; i < stats.sentryCount; i++) {
                    const s = player.userData.sentries[i];
                    const droneMesh = s.model;

                    // 1. 极其酷炫的环绕飞行效果
                    s.angle += 0.02; // 环绕速度
                    droneMesh.position.x = Math.cos(s.angle) * 4.0; // 环绕半径 4.0
                    droneMesh.position.z = Math.sin(s.angle) * 4.0;
                    // 上下规律浮动模拟悬浮引擎
                    droneMesh.position.y = 2.0 + Math.sin(now * 0.005 + i) * 0.4;

                    // 2. 雷达索敌：寻找射程内最近的敌人
                    let nearestEn = null;
                    let minDist = stats.sentryRange;

                    // 获取无人机在地图上的绝对坐标
                    const droneWorldPos = new THREE.Vector3();
                    droneMesh.getWorldPosition(droneWorldPos);

                    for (let j = 0; j < enemies.length; j++) {
                        const dist = droneWorldPos.distanceTo(enemies[j].position);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestEn = enemies[j];
                        }
                    }

                    // 3. 瞄准与开火
                    if (nearestEn) {
                        // 让无人机看向敌人 (高度设为与无人机平齐，防止枪管朝地上指)
                        droneMesh.lookAt(nearestEn.position.x, droneMesh.position.y + player.position.y, nearestEn.position.z);

                        if (now - s.lastFire > stats.sentryFireRate) {
                            s.lastFire = now;
                            // 借用开火音效
                            playSound(fireSound);

                            // 独立生成哨戒炮的微型子弹
                            const b = new THREE.Mesh(
                                new THREE.SphereGeometry(0.18), // 子弹比较小
                                new THREE.MeshBasicMaterial({ color: 0x00f2ff })
                            );

                            // 从无人机枪口位置射出
                            b.position.copy(droneWorldPos);

                            // 计算飞向敌人的方向向量
                            const dir = new THREE.Vector3().subVectors(nearestEn.position, droneWorldPos).normalize();

                            // 哨戒炮子弹速度略快一点，伤害可以绑定基础子弹伤害的一半
                            b.userData = {
                                velocity: dir.multiplyScalar(stats.bulletSpeed * 1.5),
                                owner: 'p',
                                isSentry: true // 做个标记，如果你想让它伤害低一点
                            };
                            bullets.push(b);
                            scene.add(b);
                        }
                    } else {
                        // 没发现敌人时，机炮待机转圈，朝向坦克前方
                        droneMesh.rotation.y = 0;
                    }
                }
            }
            // ----------------------------------------
            // ----------------------------------------
            // --- 7. 子弹处理 ---
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.position.add(b.userData.velocity);
                if (b.position.length() > 200) { scene.remove(b); bullets.splice(i, 1); continue; }

                if (b.userData.owner === 'p') {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (b.position.distanceTo(enemies[j].position) < 2.2) {

                            // 【新增】扣除敌人血量
                            enemies[j].userData.hp -= stats.bulletDamage;
                            // --- 插入部分：更新血条 UI ---
                            const hpPercent = Math.max(0, enemies[j].userData.hp / enemies[j].userData.maxHp);
                            enemies[j].userData.hpBar.scale.x = hpPercent;

                            // 变色逻辑：血量低于一半变黄，低于 20% 变红
                            if (hpPercent <= 0.2) enemies[j].userData.hpBar.material.color.setHex(0xff0000);
                            else if (hpPercent <= 0.5) enemies[j].userData.hpBar.material.color.setHex(0xffff00);
                            // --------------------------
                            scene.remove(b); bullets.splice(i, 1); // 子弹销毁

                            // 判断敌人是否死亡
                            if (enemies[j].userData.hp <= 0) {
                                playSound(explodeSound);

                                // --- 插入触发爆炸 ---
                                createExplosion(enemies[j].position.clone(), 0xA9A9A9);
                                scene.remove(enemies[j]); enemies.splice(j, 1);
                                gainExp(1);
                            }
                            break; // 子弹已销毁，跳出敌人循环
                        }
                    }
                } else if (b.position.distanceTo(player.position) < 1.8) {
                    playerHP -= 15; scene.remove(b); bullets.splice(i, 1);
                    updateUI();
                    if (playerHP <= 0) {
                        // --- 玩家炸成紫色碎片 ---
                        createExplosion(player.position.clone(), 0x9B409E);
                        // 让玩家模型暂时消失
                        player.visible = false;
                        triggerGameOver();
                    }
                }
            }

            camera.position.lerp(new THREE.Vector3(player.position.x, 38, player.position.z - 28), 0.08);
            camera.lookAt(player.position);
            renderer.render(scene, camera);
        }

        /** --- 6. 升级系统 (支持多语言重构) --- **/
        const upgradePool = [
            { id: 'fire', act: () => stats.multiShot++ },
            { id: 'rate', act: () => stats.fireRate *= 0.75 },
            { id: 'speed', act: () => stats.moveSpeed += 0.05 },
            { id: 'size', act: () => stats.bulletSize += 0.6 },
            { id: 'hull', act: () => { maxHP += 25; playerHP = Math.min(maxHP, playerHP + 50); } },
            { id: 'servo', act: () => stats.turretSpeed += 0.04 },
            { id: 'ram', act: () => stats.ramDamage += 0.5 },
            { id: 'dmg', act: () => stats.bulletDamage += 30 },
            {
                id: 'laser',
                act: () => {
                    stats.laserLevel++;
                    if (stats.laserLevel === 1) {
                        // 第一次获得：模型显现！
                        player.userData.laserEmitter.visible = true;
                    } else {
                        // 再次获得：每次增加 0.25 秒持续时间
                        stats.laserDuration += 250;
                    }
                }
            },
            {
                id: 'sentry',
                act: () => {
                    if (stats.sentryCount < 4) {
                        player.userData.sentries[stats.sentryCount].model.visible = true;
                        stats.sentryCount++;
                    }
                }
            }
        ];

        function gainExp(n) {
            exp += n; score += 10;
            if (exp >= expNeeded) {
                level++; exp = 0; expNeeded = Math.floor(expNeeded * 1.3) + 3;
                showUpgrade();
            }
            updateUI();
        }

        function showUpgrade() {
            gameActive = false;
            document.getElementById('pause-trigger').style.display = 'none';
            const container = document.getElementById('upgrade-options');
            container.innerHTML = '';

            // --- 插入部分：动态过滤卡池 ---
            const availableUpgrades = upgradePool.filter(opt => {
                // 如果是哨戒炮，且数量已经达到上限(4个)，就把它从本次抽卡池中踢出去
                if (opt.id === 'sentry' && stats.sentryCount >= 4) {
                    return false;
                }

                // 💡 未来扩展提示：如果你想限制激光满级为 5 级，可以接着加：
                // if (opt.id === 'laser' && stats.laserLevel >= 5) return false;

                return true; // 其他卡牌正常保留
            });

            // 从过滤后的干净卡池中，打乱并抽取 3 个
            const opts = [...availableUpgrades].sort(() => 0.5 - Math.random()).slice(0, 3);
            // -----------------------------

            opts.forEach(opt => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';

                // 从当前语言字典中动态读取卡片名字和描述
                const nameText = dict[currentLang][opt.id + 'Name'];
                const descText = dict[currentLang][opt.id + 'Desc'];

                card.innerHTML = `<h3>${nameText}</h3><p>${descText}</p>`;

                card.onclick = () => {
                    document.getElementById('pause-trigger').style.display = 'flex';
                    opt.act();
                    gameActive = true;
                    document.getElementById('upgrade-overlay').style.display = 'none';
                    animate();
                };
                container.appendChild(card);
            });
            document.getElementById('upgrade-overlay').style.display = 'flex';
        }

        function updateUI() {
            document.getElementById('hp-bar').style.width = (playerHP / maxHP * 100) + "%";
            document.getElementById('exp-bar').style.width = (exp / expNeeded * 100) + "%";
            document.getElementById('lvl-val').innerText = level;
            document.getElementById('score-val').innerText = score;
        }

        /** --- 7. 交互绑定 --- **/
        document.getElementById('start-btn').onclick = () => {
            // 预加载音效
            fireSound.load();
            explodeSound.load();
            bgm.load();

            document.getElementById('start-overlay').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            gameActive = true;
            bgm.play(); // 播放音乐
            animate();
        };

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        function triggerGameOver() {
            gameActive = false; // 停止游戏循环
            bgm.pause();        // 停止背景音乐

            // 显示结算界面并更新分数
            document.getElementById('final-score').innerText = score;
            document.getElementById('gameover-overlay').style.display = 'flex';
        }

        // 绑定重启按钮

        document.getElementById('btn-restart').onclick = function () {
            // 1. 重置基础数值
            playerHP = 100;
            maxHP = 100;
            score = 0;
            level = 1;
            exp = 0;
            expNeeded = 5;

            // 2. 重置所有升级属性到初始状态
            stats.moveSpeed = 0.22;
            stats.fireRate = 800;
            stats.bulletSize = 0.35;
            stats.bulletSpeed = 1.25;
            stats.multiShot = 1;
            stats.turretSpeed = 0.065;
            stats.bulletDamage = 50;
            stats.ramDamage = 0;

            // 3. 重置激光模块状态
            stats.laserLevel = 0;
            stats.laserDuration = 300;
            if (player.userData.laserEmitter) {
                player.userData.laserEmitter.visible = false;
                player.userData.laserBeam.visible = false;
                player.userData.isLaserActive = false;
            }

            // 4. 重置哨戒炮模块状态
            stats.sentryCount = 0;
            stats.sentryFireRate = 800;
            if (player.userData.sentries) {
                player.userData.sentries.forEach(s => s.model.visible = false);
            }

            // 5. 清理战场上的敌人和子弹
            enemies.forEach(en => {
                if (en.userData.hpGroup) scene.remove(en.userData.hpGroup);
                scene.remove(en);
            });
            bullets.forEach(b => scene.remove(b));
            enemies.length = 0;
            bullets.length = 0;

            // 6. 清理上一局残留的爆炸碎片和闪光
            debrisParticles.forEach(p => {
                scene.remove(p.mesh);
                if (!p.isLight && p.mesh.geometry) {
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                }
            });
            debrisParticles.length = 0;

            // 7. 玩家满血复活：归位并重新显示！
            player.position.set(0, 0, 0);
            player.visible = true; // <--- 就是这里修复了隐形问题

            // 8. 恢复 UI 与游戏循环
            updateUI();
            document.getElementById('gameover-overlay').style.display = 'none';
            gameActive = true;
            bgm.currentTime = 0;
            bgm.play();
            animate();
        };

        /** --- 暂停状态管理 --- **/
        let isPaused = false;

        function togglePause() {
            // 如果已经在升级或结束界面，不允许手动切换暂停
            if (!gameActive && !isPaused) return;

            isPaused = !isPaused;

            if (isPaused) {
                // 进入暂停
                gameActive = false;
                bgm.pause(); // 暂停背景音乐
                document.getElementById('pause-overlay').style.display = 'flex';
                document.getElementById('pause-trigger').innerText = '▶'; // 按钮变为播放图标
            } else {
                // 恢复游戏
                document.getElementById('pause-overlay').style.display = 'none';
                document.getElementById('pause-trigger').innerText = '‖'; // 按钮变回暂停图标
                gameActive = true;
                bgm.play(); // 恢复背景音乐
                animate(); // 重新启动动画循环
            }
        }

        // 绑定按钮点击事件
        document.getElementById('pause-trigger').onclick = togglePause;
        document.getElementById('btn-resume').onclick = togglePause;

        // 绑定键盘 P 键或 Esc 键快捷暂停
        window.addEventListener('keydown', e => {
            if (e.key.toLowerCase() === 'p' || e.key === 'Escape') {
                togglePause();
            }
        });

        // 摇杆逻辑适配
        function bindJoy(id, stickId, state) {
            const zone = document.getElementById(id), stick = document.getElementById(stickId);
            if ('ontouchstart' in window) zone.style.display = 'block';

            // 抽取更新摇杆位置的独立逻辑
            function updateStick(e) {
                // e.targetTouches 只包含按在这个特定摇杆区域内的手指
                if (e.targetTouches.length === 0) return;
                const t = e.targetTouches[0];
                const rect = zone.getBoundingClientRect();
                const dx = t.clientX - (rect.left + 60), dy = t.clientY - (rect.top + 60);
                const d = Math.min(Math.sqrt(dx * dx + dy * dy), 50), a = Math.atan2(dy, dx);
                stick.style.transform = `translate(${Math.cos(a) * d}px, ${Math.sin(a) * d}px)`;
                state.x = (Math.cos(a) * d) / 50; state.y = (Math.sin(a) * d) / 50;
            }

            // 监听触摸开始
            zone.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 阻止浏览器默认行为（如滚动网页）
                state.active = true;
                updateStick(e); // 刚按下去也要更新一下位置，不然摇杆不跟手
            }, { passive: false });

            // 监听触摸移动
            zone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (state.active) updateStick(e);
            }, { passive: false });

            // 监听触摸结束与意外中断
            const endJoy = (e) => {
                e.preventDefault();
                // 只有当这个区域内没有手指时才归位
                if (e.targetTouches.length === 0) {
                    state.active = false;
                    state.x = 0;
                    state.y = 0;
                    stick.style.transform = 'translate(0,0)';
                }
            };
            zone.addEventListener('touchend', endJoy, { passive: false });
            zone.addEventListener('touchcancel', endJoy, { passive: false });
        }

        bindJoy('joy-left', 'stick-l', joyL);
        bindJoy('joy-right', 'stick-r', joyR);

        setInterval(() => {
            if (gameActive && enemies.length < 20 + level * 10) {
                const en = createTank(0xff4444);

                // --- 插入部分：初始化血量数据 ---
                const maxHealth = 80 + (level * 20); // 随等级成长
                en.userData.maxHp = maxHealth;
                en.userData.hp = maxHealth;
                // ------------------------------

                const a = Math.random() * Math.PI * 2;
                en.position.set(player.position.x + Math.cos(a) * 70, 0, player.position.z + Math.sin(a) * 70);
                enemies.push(en);
            }
        }, 1000);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


    </script>
</body>

</html>