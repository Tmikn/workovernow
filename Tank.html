<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>黑神话：坦克</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a0a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* UI 层 */
        #ui {
            position: fixed; top: 20px; left: 20px; color: white;
            pointer-events: none; z-index: 100; width: calc(100% - 40px);
        }
        .stats-row { display: flex; justify-content: space-between; align-items: center; }
        .score-display { font-size: 20px; font-weight: bold; color: #9B409E; text-shadow: 0 0 10px #9B409E; }
        
        /* 血条和经验条 */
        .bar-container { width: 200px; height: 10px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3); margin-top: 5px; overflow: hidden; }
        #hp-bar { width: 100%; height: 100%; background: #ff4444; transition: width 0.2s; }
        #exp-bar { width: 0%; height: 100%; background: #00f2ff; transition: width 0.2s; }

        /* 升级界面 */
        #upgrade-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            flex-direction: column; justify-content: center; align-items: center;
            z-index: 3000;
        }
        .upgrade-card {
            background: #1a1a1a; border: 2px solid #9B409E; color: white;
            padding: 20px; margin: 10px; width: 280px; cursor: pointer;
            transition: transform 0.2s, background 0.2s; text-align: center;
        }
        .upgrade-card:hover { transform: scale(1.05); background: #2a2a2a; }
        .upgrade-card h3 { color: #00f2ff; margin: 0 0 10px 0; }

        /* 死亡界面 */
        #death-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; justify-content: center; align-items: center;
            color: #ff4444; z-index: 2000;
        }
        button { padding: 12px 30px; background: #9B409E; color: white; border: none; cursor: pointer; font-size: 16px; margin-top: 20px; border-radius: 4px; }

        /* 摇杆 */
        #joystick-container { position: fixed; bottom: 40px; left: 40px; width: 120px; height: 120px; z-index: 1000; touch-action: none; display: none; }
        #joystick-base { width: 100%; height: 100%; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); }
        #joystick-stick { width: 50px; height: 50px; border-radius: 50%; background: #9B409E; position: absolute; top: 35px; left: 35px; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="stats-row">
            <div>
                <div class="score-display">等级 <span id="lvl-val">1</span></div>
                <div class="bar-container" style="width: 250px;"><div id="exp-bar"></div></div>
                <div style="font-size: 10px; color: #00f2ff;">经验同步率 (EXPERIENCE)</div>
            </div>
            <div style="text-align: right;">
                <div class="score-display" id="score-val">0</div>
                <div class="bar-container"><div id="hp-bar"></div></div>
                <div style="font-size: 10px; color: #ff4444;">系统完整性 (INTEGRITY)</div>
            </div>
        </div>
    </div>

    <div id="upgrade-overlay">
        <h1 style="color: #9B409E; text-shadow: 0 0 15px #9B409E;">系统进化 (UPGRADE)</h1>
        <div id="upgrade-options" style="display: flex; flex-wrap: wrap; justify-content: center;"></div>
    </div>

    <div id="death-overlay">
        <h1>连接断开 (DEFEATED)</h1>
        <p style="color: white;">最终战果: <span id="final-score">0</span></p>
        <button onclick="location.reload()">重新启动系统</button>
    </div>

    <div id="joystick-container">
        <div id="joystick-base"><div id="joystick-stick"></div></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. 核心状态 ---
        let gameActive = true, score = 0, level = 1, exp = 0, expNeeded = 5;
        let playerHP = 100, maxHP = 100;
        const enemies = [], bullets = [], keys = {};
        let joystickData = { x: 0, y: 0, active: false };

        // 玩家属性 (Rougelike 可升级项)
        const stats = {
            moveSpeed: 0.2,
            fireRate: 800, // 毫秒间隔
            bulletSize: 0.25,
            bulletSpeed: 0.8,
            multiShot: 1,
            lastFire: 0
        };

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0a, 20, 150);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 环境
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(10, 20, 10);
        scene.add(sun);
        scene.add(new THREE.GridHelper(500, 100, 0x9B409E, 0x222222));

        // --- 2. 实体工厂 ---
        function createTank(color) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 0.8, 2.5), new THREE.MeshPhongMaterial({ color }));
            body.position.y = 0.5;
            group.add(body);
            const turret = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.6, 1.2), new THREE.MeshPhongMaterial({ color }));
            turret.position.y = 1.2;
            group.add(turret);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.8), new THREE.MeshPhongMaterial({ color: 0x333333 }));
            barrel.rotation.x = Math.PI/2;
            barrel.position.set(0, 1.2, 1);
            group.add(barrel);
            group.userData = { radius: 1.5 };
            scene.add(group);
            return group;
        }

        const player = createTank(0x9B409E);

        // --- 3. 升级逻辑 (三选一) ---
        const upgradePool = [
            { id: 'speed', name: '超频驱动', desc: '提升移动速度 15%', action: () => stats.moveSpeed += 0.04 },
            { id: 'fireRate', name: '快速装填', desc: '提升射速 20%', action: () => stats.fireRate *= 0.8 },
            { id: 'bulletSize', name: '大口径弹药', desc: '弹药体积增加 30%', action: () => stats.bulletSize += 0.15 },
            { id: 'bulletSpeed', name: '电磁加速', desc: '子弹飞行速度提升 25%', action: () => stats.bulletSpeed += 0.2 },
            { id: 'multiShot', name: '并联炮管', desc: '额外发射一颗子弹', action: () => stats.multiShot += 1 },
            { id: 'heal', name: '纳米修复', desc: '立即恢复 50% 生命并提升上限', action: () => { maxHP += 20; playerHP = Math.min(maxHP, playerHP + maxHP * 0.5); } }
        ];

        function showUpgradeScreen() {
            gameActive = false;
            const container = document.getElementById('upgrade-options');
            container.innerHTML = '';
            
            // 随机选三个
            const shuffled = [...upgradePool].sort(() => 0.5 - Math.random()).slice(0, 3);
            
            shuffled.forEach(opt => {
                const div = document.createElement('div');
                div.className = 'upgrade-card';
                div.innerHTML = `<h3>${opt.name}</h3><p>${opt.desc}</p>`;
                div.onclick = () => {
                    opt.action();
                    closeUpgradeScreen();
                };
                container.appendChild(div);
            });
            document.getElementById('upgrade-overlay').style.display = 'flex';
        }

        function closeUpgradeScreen() {
            gameActive = true;
            document.getElementById('upgrade-overlay').style.display = 'none';
            animate(); // 重新开始循环
        }

        // --- 4. 战斗逻辑 ---
        function fireBullet(owner, isPlayer = false) {
            const count = isPlayer ? stats.multiShot : 1;
            for(let i=0; i<count; i++) {
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(isPlayer ? stats.bulletSize : 0.2), 
                    new THREE.MeshBasicMaterial({ color: isPlayer ? 0x00f2ff : 0xff4444 })
                );
                bullet.position.copy(owner.position).add(new THREE.Vector3(0, 1.2, 0));
                
                const angleOffset = (i - (count-1)/2) * 0.15; // 多重射击偏转
                const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(owner.quaternion);
                if(isPlayer) dir.applyAxisAngle(new THREE.Vector3(0,1,0), angleOffset);

                bullet.userData = { 
                    velocity: dir.multiplyScalar(isPlayer ? stats.bulletSpeed : 0.4), 
                    owner: isPlayer ? 'p' : 'e' 
                };
                bullets.push(bullet);
                scene.add(bullet);
            }
        }

        function spawnEnemy() {
            if (!gameActive || enemies.length > 10 + level * 2) return;
            const enemy = createTank(0xff4444);
            const angle = Math.random() * Math.PI * 2;
            const dist = 60; // 在视野外生成
            enemy.position.set(
                player.position.x + Math.cos(angle) * dist,
                0,
                player.position.z + Math.sin(angle) * dist
            );
            enemy.userData.lastFire = Date.now();
            enemies.push(enemy);
        }

        // --- 5. 循环与更新 ---
        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);

            // 移动控制
            if (keys['w']) player.translateZ(stats.moveSpeed);
            if (keys['s']) player.translateZ(-stats.moveSpeed);
            if (keys['a']) player.rotation.y += 0.05;
            if (keys['d']) player.rotation.y -= 0.05;
            
            if (joystickData.active) {
                player.rotation.y -= joystickData.x * 0.05;
                player.translateZ(-joystickData.y * (stats.moveSpeed + 0.05));
            }

            // 自动射击 (幸存者模式核心)
            if (Date.now() - stats.lastFire > stats.fireRate) {
                fireBullet(player, true);
                stats.lastFire = Date.now();
            }

            // AI 逻辑
            for (let i = enemies.length - 1; i >= 0; i--) {
                const en = enemies[i];
                const dist = en.position.distanceTo(player.position);
                const dir = new THREE.Vector3().subVectors(player.position, en.position);
                
                en.rotation.y = THREE.MathUtils.lerp(en.rotation.y, Math.atan2(dir.x, dir.z), 0.05);
                en.translateZ(0.06 + (level * 0.01)); // 敌人随等级加速

                // 敌人开火
                if (Date.now() - en.userData.lastFire > 3000 && dist < 40) {
                    fireBullet(en, false);
                    en.userData.lastFire = Date.now();
                }

                // 身体碰撞
                if (dist < 3) {
                    playerHP -= 0.5; // 撞击伤害
                    updateUI();
                }
            }

            // 子弹处理
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.position.add(b.userData.velocity);

                if (b.position.distanceTo(player.position) > 100) {
                    scene.remove(b); bullets.splice(i, 1); continue;
                }

                if (b.userData.owner === 'p') {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (b.position.distanceTo(enemies[j].position) < 2) {
                            scene.remove(enemies[j]); enemies.splice(j, 1);
                            scene.remove(b); bullets.splice(i, 1);
                            gainExp(1);
                            break;
                        }
                    }
                } else if (b.position.distanceTo(player.position) < 2) {
                    playerHP -= 15;
                    scene.remove(b); bullets.splice(i, 1);
                    updateUI();
                    if (playerHP <= 0) gameOver();
                }
            }

            const camOffset = new THREE.Vector3(0, 20, -25).applyQuaternion(player.quaternion);
            camera.position.lerp(player.position.clone().add(camOffset), 0.1);
            camera.lookAt(player.position);
            renderer.render(scene, camera);
        }

        function gainExp(amount) {
            exp += amount;
            score += amount * 10;
            if (exp >= expNeeded) {
                level++;
                exp = 0;
                expNeeded = Math.floor(expNeeded * 1.3) + 5;
                showUpgradeScreen();
            }
            updateUI();
        }

        function updateUI() {
            document.getElementById('score-val').innerText = score;
            document.getElementById('lvl-val').innerText = level;
            document.getElementById('hp-bar').style.width = (playerHP / maxHP * 100) + "%";
            document.getElementById('exp-bar').style.width = (exp / expNeeded * 100) + "%";
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('death-overlay').style.display = 'flex';
            document.getElementById('final-score').innerText = score;
        }

        // --- 6. 交互绑定 ---
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        
        // 移动端支持
        if ('ontouchstart' in window) {
            document.getElementById('joystick-container').style.display = 'block';
            const stick = document.getElementById('joystick-stick');
            document.getElementById('joystick-container').addEventListener('touchstart', () => joystickData.active = true);
            window.addEventListener('touchmove', e => {
                if (!joystickData.active) return;
                const t = e.touches[0];
                const base = document.getElementById('joystick-base').getBoundingClientRect();
                const dx = t.clientX - (base.left + 60), dy = t.clientY - (base.top + 60);
                const d = Math.min(Math.sqrt(dx*dx+dy*dy), 50), a = Math.atan2(dy, dx);
                stick.style.transform = `translate(${Math.cos(a)*d}px, ${Math.sin(a)*d}px)`;
                joystickData.x = (Math.cos(a)*d)/50; joystickData.y = (Math.sin(a)*d)/50;
            });
            window.addEventListener('touchend', () => { 
                joystickData.active = false; 
                stick.style.transform = 'translate(0,0)'; 
            });
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        setInterval(spawnEnemy, 1500);
        updateUI();
        animate();
    </script>
</body>
</html>